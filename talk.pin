#!/usr/bin/env pinpoint
[duration=40] [black] [shading-opacity=1.0] [transition=fade-fast]

-- [photos/2889678711_50c3e81405_b.jpg]
(R) Writing a Wayland Compositor

# The idea of this talk is to hopefully give some insight into writing
# a wayland compositor based on some of our early experiences. So far
# we've written three compositors; each progressively more capable
# than the last and found it a good way of learning what's involved.
#
# Proviso: Significant portions of what we talk about here is evolving
# rapidly.

-- [photos/2889678711_50c3e81405_b.jpg]
Robert Bragg

# - Intel Open Source Technology Center, based in London
# - Maintainer for the Cogl 3D graphics API
# - Done lots of work on Clutter
# - I've done a fair amount of work on Window managers and Graphics
#   drivers in the past.

-- [photos/2889678711_50c3e81405_b.jpg]
(N) Neil Roberts

# - Also on the visualization team in the Intel OTC.
# - Part-maintainer of Cogl
# - Recently got involved in the Wayland effort

-- [stage-color=black] [xarch.png] [bottom-right]
The current X
architecture

# The main thing to point out here is that the X architecture requires
# us to put the compositor into a separate process.
#
# Because the xserver doesn't know about the compositor scenegraph
# used to render windows its currently basically infeasible to support
# input transformations with this architecture.
#
# Because the compositor isn't directly responsible for display output
# it's also very difficult to have fine grained control over what gets
# displayed; for example compositors want to control when fullscreen
# applications should be scanned out directly by the display hardware
# and they also want to take full advantage of the displays overlay
# capabilities for blending sprites, ui and video layers together.

-- [stage-color=black] [wlarch.png] [bottom-left]
The new
architecture

# The thing to point out here is that wayland combines the compositor
# into the server process.
#
# Input redirection is now trivial because the input devices and the
# scenegraph are now owned by the same process.
#
# We can totally control the display hardware in the compositor so we
# can do whatever

-- [photos/1346915953_edab99dab8_b.jpg]
libwayland-server

#Explain that this lib provides just the protocol marshaling stuff +
#some utils for dealing with input grabs, data device,

#Note: there's nothing specific to the rendering architecture here

-- [photos/1346915953_edab99dab8_b.jpg]
Clients in their own world

# Explain that client surfaces all have a private coordinate space and
# its not possible to discover the surfaces of other clients like you
# can under X.
#
# This makes the compositor more free to place windows wherever it
# wants and apply whatever transformations it likes without having to
# describe those transformations to the clients

-- [photos/1346915953_edab99dab8_b.jpg]
Clients are King

# Anything that's not a shared resource is handled in the client:
# - rendering,
# - client side decorations
# - keyboard maps / interpreting keyboard events

-- [photos/3536874376_8faa3e977e_b.jpg]
(R) How a compositor looks..

# We're going to run through the basic design and components of a
# Wayland compositor...

-- [photos/3536874376_8faa3e977e_b.jpg]
Interfaces, Events & Requests

# All interactions over the wayland protocol happen according to
# interfaces that are declared in XML


-- [font=Monospace 20px] [photos/3536874376_8faa3e977e_b.jpg]
&lt;<span color="#0000FF">protocol</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">xserver</span><span color="#8B2252">&quot;</span>>

  &lt;<span color="#0000FF">interface</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">xserver</span><span color="#8B2252">&quot;</span> <span color="#A0522D">version</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">1</span><span color="#8B2252">&quot;</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">set_window_id</span><span color="#8B2252">&quot;</span>>
      &lt;<span color="#0000FF">arg</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">surface</span><span color="#8B2252">&quot;</span> <span color="#A0522D">type</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">object</span><span color="#8B2252">&quot;</span> <span color="#A0522D">interface</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">wl_surface</span><span color="#8B2252">&quot;</span>/>
      &lt;<span color="#0000FF">arg</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">id</span><span color="#8B2252">&quot;</span> <span color="#A0522D">type</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">uint</span><span color="#8B2252">&quot;</span>/>
    &lt;/<span color="#0000FF">request</span>>

    &lt;<span color="#0000FF">event</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">client</span><span color="#8B2252">&quot;</span>>
      &lt;<span color="#0000FF">arg</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">fd</span><span color="#8B2252">&quot;</span> <span color="#A0522D">type</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">fd</span><span color="#8B2252">&quot;</span>/>
    &lt;/<span color="#0000FF">event</span>>

    &lt;<span color="#0000FF">event</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">listen_socket</span><span color="#8B2252">&quot;</span>>
      &lt;<span color="#0000FF">arg</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">fd</span><span color="#8B2252">&quot;</span> <span color="#A0522D">type</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">fd</span><span color="#8B2252">&quot;</span>/>
    &lt;/<span color="#0000FF">event</span>>
  &lt;/<span color="#0000FF">interface</span>>

&lt;/<span color="#0000FF">protocol</span>>

# Don't worry about the details of what this interface is for but explain that
# interfaces are declared using xml and interfaces are made of requests and
# events.
#
# Explain that no requests rely on have synchronous replies
#

# Give examples of the different interfaces in a compositor
#   - wl_display - bind
#   - wl_compositor - create_surface
#   - wl_shm
#   - wl_output
#   - wl_input_device


# An interface defines a set of requests and events which can each
# have a name and a set of arguments with names and types.
#
# Requests are used for clients to ask something of the compositor.
#
# Explain that requests can't send synchronous replies, which makes
# sense for a cross process IPC protocol, but instead compositors can
# send events to send information out to clients.

#Example of sending an event from a compositor
#      wl_resource_post_event (&callback->resource,
#                              WL_CALLBACK_DONE, get_time ());


-- [photos/3536874376_8faa3e977e_b.jpg]
Objects

# Explain that interfaces are implemented by objects.
# Explain how compositors advertise objects implementing interfaces to
# clients
# - global objects that get advertised via events when a client first connects

-- [font=Monospace 20px] [photos/3536874376_8faa3e977e_b.jpg]
<i>Example of registering a new global object in a compositor</i>

<tt>
  <span color="#A020F0">if</span> (!wl_display_add_global (compositor.wayland_display,
                              &amp;wl_compositor_interface,
                              &amp;compositor,
                              compositor_bind))
    g_error (<span color="#8B2252">&quot;Failed to register wayland compositor object&quot;</span>);
</tt>

# Whenever a client binds an object then the compositor constructs a
# server side resource representing the clients view of that object.

#E.g.
#  if (strcmp (interface, "wl_compositor") == 0)
#    wayland_renderer->wayland_compositor =
#      wl_display_bind (display, id, &wl_compositor_interface);
#


#  compositor.wayland_shm = wl_shm_init (compositor.wayland_display,
#                                        &amp;shm_callbacks);

# This is an example of how to register an object
#
# This registers the global compostor object. This is the key object
# that clients will use to create surfaces.
-- [font=Monospace 20px] [photos/3536874376_8faa3e977e_b.jpg]
<i>This part is a callback</i>

<tt>
  <span color="#A020F0">if</span> (!wl_display_add_global (compositor.wayland_display,
                              &amp;wl_compositor_interface,
                              &amp;compositor,
                              <span background="#ff0000">compositor_bind</span>))
    g_error (<span color="#8B2252">&quot;Failed to register wayland compositor object&quot;</span>);
</tt>


#  compositor.wayland_shm = wl_shm_init (compositor.wayland_display,
#                                        &amp;shm_callbacks);

-- [font=Monospace 20px] [photos/3536874376_8faa3e977e_b.jpg]
<i>Implementation</i>
<tt>
<span color="#A020F0">static</span> <span color="#228B22">voi</span><span color="#228B22">d</span>
<span color="#0000FF">compositor_bind</span> (<span color="#A020F0">struct</span> <span color="#228B22">wl_client</span> *<span color="#A0522D">client</span>,
                 <span color="#228B22">void</span> *<span color="#A0522D">data</span>,
                 <span color="#228B22">guint32</span> <span color="#A0522D">version</span>,
                 <span color="#228B22">guint32</span> <span color="#A0522D">id</span>)
{
  <span color="#228B22">CoglandComposito</span><span color="#228B22">r</span> *<span color="#A0522D">compositor</span> = data;

  wl_client_add_object (client, &amp;wl_compositor_interface,
                        &amp;cogland_compositor_interface, id, compositor);
}
</tt>


# The callback will be called whenever a client binds the objects.
# This creates a new resource on the compositor side to represent the
# clients view of the object.

-- [photos/depot.jpg]
(N) The rendering architecture...

-- [photos/depot.jpg]
SHM buffers

# This is a simple mechanism for sharing buffers
#
# This client can directly render into the system-mapped memory using
# a software rendering library such as Cairo.
#
# This should probably be avoided by clients because it requires a
# copy from the shared memory to a texture in the compositor.
-- [photos/depot.jpg]
EGL

# EGL is a platform independent window system API
#
# It is used to create a GL or GLES context and bind into to a window
# or offscreen buffer.
#
# It can be considered a replacement for GLX.
-- [font=45px] [photos/depot.jpg]
eglCreateDisplay(NativeDisplayType display)

# For example, to create an EGL display you have to pass it a
# NativeDisplayType. This is a platform specific pointer representing
# the display. Eg, for X it could be the X Display* pointer. It is up
# to the EGL implementation to interpret this pointer correctly.

-- [bottom] [egl-in-wayland.png]
EGL in Wayland

# Both client and compositor link to EGL.
#
# It is up to the implementation for how it passes buffers between
# client and compositor. It can define whatever internal extensions
# needed.
#
# In Mesa it will create a wl_drm global interface for the client to use.

-- [photos/depot.jpg]
EGL in Clients...

# The EGL implementation has to have specific support to interpret
# EGLNativeDisplayType and EGLNativeWindowType as wayland types.
# The client would then do the following:
-- [photos/depot.jpg]
<i>Create a wayland display object</i>

<tt>
<span color="#A020F0">struct</span> <span color="#228B22">wl_displa</span><span color="#228B22">y</span> *<span color="#A0522D">display</span> =
  wl_display_connect (<span color="#008B8B">NULL</span>);
</tt>

# This returns an object representing the connection on the socket to
# the Wayland display server. This can be considered an equivalent to
# the Display* pointer in X.
-- [font=28px] [photos/depot.jpg]
<i>Bind to the wl_compositor interface</i>
<tt>
  <span color="#A020F0">if</span> (strcmp(interface, <span color="#8B2252">&quot;wl_compositor&quot;</span>) == 0)
    d->compositor =
      wl_display_bind(display, id,
                      &amp;wl_compositor_interface);
</tt>

# The client needs a handle to represent the compositor's global
# wl_compositor interface. It can get this by handle the 'global'
# event on the wl_display interface and then binding the object as
# shown.
-- [photos/depot.jpg]
wl_compositor::create_surface

# This is a method on the compositor's wl_compositor object to create
# a surface. The client generates an ID for the surface.
--[font=28px] [photos/depot.jpg]
<i>libwayland-egl:</i>

<tt>
<span color="#A020F0">struct</span> <span color="#228B22">wl_egl_windo</span><span color="#228B22">w</span> *
<span color="#0000FF">wl_egl_window_create</span>(<span color="#A020F0">struct</span> <span color="#228B22">wl_surface</span> *<span color="#A0522D">surface</span>,
                     <span color="#228B22">int</span> <span color="#A0522D">width</span>,
                     <span color="#228B22">int</span> <span color="#A0522D">height</span>);
</tt>

# libwayland-egl is some wayland-specific functions in the EGL implementation
# This function is used to create a structure which combines a size with a
# wayland surface.
-- [font=35px] [photos/depot.jpg]
eglCreateWindowSurface(EGLNativeWindowType)

# Once the client has a wl_egl_window* pointer it can pass that to
# EGL as the native window type to create a regular EGL surface.
#
# The surface can then be used with eglMakeCurrent to bind the GL context.
# From then on the application can just use regular GL or GLES.
-- [photos/depot.jpg]
EGL in the Compositor

# On the compositor side the compositor can use whatever EGL platform
# it likes. For example it could use an X display and an X window as a
# surface to create a compositor that is nested under X. However the
# EGL implementation has to implement this one extension...
-- [photos/depot.jpg]
EGL_WL_bind_wayland_display
# ... this extension contains one function...
-- [font=Monospace 20px] [photos/depot.jpg]
eglBindWaylandDisplayWL()

# ... The compositor must call this to tell the EGL implementation
# that it should accept buffers passed in from clients. How this works
# is up to the implementation but in Mesa it will register a global
# object with the wl_drm interface.

-- [photos/2889657735_5234d83de4_b.jpg]
(R) Wayland outputs

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
  &lt;<span color="#0000FF">interface</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">wl_output</span><span color="#8B2252">&quot;</span> <span color="#A0522D">version</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">1</span><span color="#8B2252">&quot;</span>>
    &lt;<span color="#0000FF">enum</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">subpixel</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">enum</span>>
    &lt;<span color="#0000FF">event</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">geometry</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">event</span>>
    &lt;<span color="#0000FF">enum</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">mode</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">enum</span>>
    &lt;<span color="#0000FF">event</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">mode</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">event</span>>
  &lt;/<span color="#0000FF">interface</span>>

-- [photos/2889657735_5234d83de4_b.jpg]
The Compositor object

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
  &lt;<span color="#0000FF">interface</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">wl_compositor</span><span color="#8B2252">&quot;</span> <span color="#A0522D">version</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">1</span><span color="#8B2252">&quot;</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">create_surface</span><span color="#8B2252">&quot;</span>>
      &lt;<span color="#0000FF">arg</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">id</span><span color="#8B2252">&quot;</span> <span color="#A0522D">type</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">new_id</span><span color="#8B2252">&quot;</span> <span color="#A0522D">interface</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">wl_surface</span><span color="#8B2252">&quot;</span>/>
    &lt;/<span color="#0000FF">request</span>>
  &lt;/<span color="#0000FF">interface</span>>

# Remember to note that the xml snippet is a pseudo description

-- [photos/2889657735_5234d83de4_b.jpg]
The wl_surface interface

-- [font=Monospace 20px] [photos/2889657735_5234d83de4_b.jpg]
  &lt;<span color="#0000FF">interface</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">wl_surface</span><span color="#8B2252">&quot;</span> <span color="#A0522D">version</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">1</span><span color="#8B2252">&quot;</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">destroy</span><span color="#8B2252">&quot;</span> <span color="#A0522D">type</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">destructor</span><span color="#8B2252">&quot;</span>/>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">attach</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">request</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">damage</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">request</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">frame</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">request</span>>
  &lt;/<span color="#0000FF">interface</span>>

-- [photos/depot.jpg]
Handling buffer attach requests

-- [font=Monospace 20px] [photos/depot.jpg]
<i>Handling a buffer attach from a client</i>
<tt>
<span color="#A020F0">static</span> <span color="#228B22">voi</span><span color="#228B22">d</span>
<span color="#0000FF">cogland_surface_attach_buffer</span> (<span color="#A020F0">struct</span> <span color="#228B22">wl_client</span> *<span color="#A0522D">wayland_client</span>,
                               <span color="#A020F0">struct</span> <span color="#228B22">wl_resource</span> *<span color="#A0522D">wayland_surface_resource</span>,
                               <span color="#A020F0">struct</span> <span color="#228B22">wl_resource</span> *<span color="#A0522D">wayland_buffer_resource</span>,
                               <span color="#228B22">gint32</span> <span color="#A0522D">dx</span>, <span color="#228B22">gint32</span> <span color="#A0522D">dy</span>)
{
  <span color="#B22222">/</span><span color="#B22222">*</span><span color="#B22222">.... </span><span color="#B22222">*/</span>
  buffer->texture =
    cogl_wayland_texture_2d_new_from_buffer (compositor->cogl_context,
                                             wayland_buffer,
                                             &amp;error);
  <span color="#B22222">/</span><span color="#B22222">*</span><span color="#B22222">...</span><span color="#B22222">*/</span>
}
</tt>


-- [photos/depot.jpg]
Frame callbacks


# This function is called by the client whenever it has finished
# rendering a frame to pass the new buffer to the server. The client
# implementation of EGL will call this whenever eglSwapBuffers is
# called.
#
# In the Cogland example we use a function from the Cogl API to
# convert the buffer to a texture.

# With current X compositors it can be quite difficult to synchronize
# rendering clients with the redraw of the compositor.
#
# It's quite easy to end up in a situation where the client is
# renderering at a very high frame-rate and hogging the GPU. The
# compositor is then only able to render at a much lower frame-rate so
# most of the frames of the client are dropped. The client's rendering
# is therefore mostly redundant.
#
# Wayland tries to fix this problem by sending a 'frame done'
# notification to all clients whenever it has completed rendering a
# composited frame. That way clients can rate limit themselves to
# frames that will actually get displayed.
#
# This can make a big power saving.

-- [photos/depot.jpg] [font=25px]
<i>Post frame callback-done events on paint</i>
<tt>
  <span color="#A020F0">while</span> (!g_queue_is_empty (&amp;compositor->frame_callbacks))
    {
      <span color="#228B22">CoglandFrameCallbac</span><span color="#228B22">k</span> *<span color="#A0522D">callback</span> =
        g_queue_peek_head (&amp;compositor->frame_callbacks);

      wl_resource_post_event (&amp;callback->resource,
                              WL_CALLBACK_DONE, get_time ());
      wl_resource_destroy (&amp;callback->resource, 0);
    }
</tt>

-- [photos/2889678725_55f1e7fbeb_b.jpg]
The wl_shell_surface interface

-- [font=Monospace 20px] [photos/2889678725_55f1e7fbeb_b.jpg]
  &lt;<span color="#0000FF">interface</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">wl_shell_surface</span><span color="#8B2252">&quot;</span> <span color="#A0522D">version</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">1</span><span color="#8B2252">&quot;</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">move</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">request</span>>
    &lt;<span color="#0000FF">enum</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">resize</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">enum</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">resize</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">request</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">set_toplevel</span><span color="#8B2252">&quot;</span>/>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">set_transient</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">request</span>>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">set_fullscreen</span><span color="#8B2252">&quot;</span>/>
    &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">set_popup</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">request</span>>
    &lt;<span color="#0000FF">event</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">configure</span><span color="#8B2252">&quot;</span>> ... &lt;/<span color="#0000FF">event</span>>
    &lt;<span color="#0000FF">event</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">popup_done</span><span color="#8B2252">&quot;</span>/>
  &lt;/<span color="#0000FF">interface</span>>

# This code posts an event on the resource belonging to the callback
# registered for the notification.
#
# The resource is then automatically destroyed. This is part of the
# contract of the callback interface.

-- [photos/white-house.jpg]
(N) libgbm

#Makes allocating drm buffers easy
#

-- [font=Monospace 40px] [photos/white-house.jpg]
gbm_create_device()

-- [font=Monospace 40px] [photos/white-house.jpg]
eglGetDisplay() with gbm device

-- [font=Monospace 40px] [photos/white-house.jpg]
struct gbm_surface

#Explain that a gbm surface is just a swap-chain of buffers but
#there's nothing KMS specific about a gbm surface

-- [font=Monospace 40px] [photos/white-house.jpg]
struct gbm_surface *gbm_surface_create()

#CAVEAT: This api is in flux!
#Credit Ander Conselvan de Oleveira for these patches

#Encapsulates the data structure of swap chain but doesn't actively
#control your display hardware

-- [font=Monospace 40px] [photos/white-house.jpg]
eglCreateWindowSurface() with gbm_surface


-- [font=Monospace 40px] [photos/white-house.jpg]
eglSwapBuffers()

-- [font=Monospace 40px] [photos/white-house.jpg]
gbm_surface_lock_front_buffer()
gbm_surface_release_buffer()

# Used to be named gbm_surface_get/release_bo()




-- [photos/river.jpg]
(R) Kernel Mode Setting Taster

-- [photos/river.jpg]
Connectors, Encoders & CRTCs

-- [photos/river.jpg]
Query the KMS resources...

-- [font=Monospace 20px] [photos/river.jpg]
resources = drmModeGetResources (fd);

-- [photos/river.jpg]
Look for connected connector...

-- [font=Monospace 20px] [photos/river.jpg]
  <span color="#A020F0">for</span> (i = 0; i &lt; resources->count_connectors; i++)
    {
      <span color="#228B22">drmModeConnecto</span><span color="#228B22">r</span> *<span color="#A0522D">connector</span> =
        drmModeGetConnector (fd, resources->connectors[i]);

      <span color="#A020F0">if</span> (connector &amp;&amp;
          connector->connection == DRM_MODE_CONNECTED &amp;&amp;
          connector->count_modes > 0 &amp;&amp;
          !is_connector_excluded (connector->connector_id,
                                  excluded_connectors,
                                  n_excluded_connectors))
        <span color="#A020F0">return</span> connector;
      drmModeFreeConnector(connector);
    }
-- [photos/river.jpg]
Pick an encoder...

-- [font=Monospace 20px] [photos/river.jpg]
encoder = drmModeGetEncoder (fd, connector->encoders[0]);

-- [photos/river.jpg]
Save the CRTC mode

-- [font=Monospace 20px] [photos/river.jpg]
saved_crtc = drmModeGetCrtc (fd, encoder->crtc_id);

-- [photos/river.jpg]
Pick a mode...

-- [font=Monospace 20px] [photos/river.jpg]
<span color="#228B22">drmModeModeInf</span><span color="#228B22">o</span> <span color="#A0522D">mode</span> = connector->modes[0];

-- [photos/river.jpg]
Create a KMS framebuffer handle

-- [font=Monospace 20px] [photos/river.jpg]
<span color="#228B22">uint32_</span><span color="#228B22">t</span> <span color="#A0522D">fb_id</span>;

handle = gbm_bo_get_handle (kms_onscreen->next_bo).u32;
pitch = gbm_bo_get_pitch (kms_onscreen->next_bo);

drmModeAddFB (fd, width, height,
	      24 <span color="#B22222">/* </span><span color="#B22222">depth </span><span color="#B22222">*/</span>, 32 <span color="#B22222">/* </span><span color="#B22222">bpp </span><span color="#B22222">*/</span>, pitch,
	      handle, &amp;fb_id);

-- [photos/river.jpg]
Set the CRTC mode

-- [font=Monospace 20px] [photos/river.jpg]
drmModeSetCrtc (fd, encoder->crtc_id, fb_id,
		0 <span color="#B22222">/* </span><span color="#B22222">x </span><span color="#B22222">*/</span>,
		0 <span color="#B22222">/* </span><span color="#B22222">y </span><span color="#B22222">*/</span>,
		connector_id, 1 <span color="#B22222">/* </span><span color="#B22222">n_connectors </span><span color="#B22222">*/</span>,
		&amp;mode);

-- [photos/parish.jpg]
(N) TTY handling

-- [photos/parish.jpg]
Block input to the tty

-- [font=Monospace 20px] [photos/parish.jpg]
tcflush(tty->fd, TCIFLUSH);

-- [photos/parish.jpg]
Handle signals for vt switching

-- [font=Monospace 20px] [photos/parish.jpg]
mode.mode = VT_PROCESS;
mode.relsig = SIGUSR1;
mode.acqsig = SIGUSR2;
<span color="#A020F0">if</span> (ioctl(tty->fd, VT_SETMODE, &amp;mode) &lt; 0) {
	g_warning (<span color="#8B2252">&quot;failed to take control of vt handling\\n&quot;</span>);
	<span color="#A020F0">return</span> <span color="#008B8B">NULL</span>;
}

-- [photos/parish.jpg]
Enter and leave graphics mode on the tty

-- [font=Monospace 20px] [photos/parish.jpg]
ret = ioctl(tty->fd, KDSETMODE, KD_GRAPHICS);
<span color="#A020F0">if</span> (ret) {
	g_warning (<span color="#8B2252">&quot;failed to set KD_GRAPHICS mode on tty: %m\\n&quot;</span>);
	<span color="#A020F0">return</span> <span color="#008B8B">NULL</span>;
}

-- [photos/bridge.jpg]
(R) xwayland

# Introduce that X wayland is a means to support legacy X clients
#
# Introduce that the compositor is responsible for starting an X
# wayland server for X clients to connect too.

-- [photos/bridge.jpg]
Starting X Wayland lazily...

# Introduce the idea of loading X wayland lazily only when we have X
# clients that require an xserver for compatibility.
# 
#

-- [photos/bridge.jpg]
Create a lock file

# This is just a case of iterating though the display number space
# looking for a free display number so we can open a free
# /tmp/.X11-lock file (checking existing lock files to see if they are
# stale) before we go ahead and open a unix domain socket.

-- [photos/bridge.jpg]
Open a unix domain socket

# Once we have found a free display number we can create a corresponding
# /tmp/.X11-unix/X? unix domain socket for X clients to connect too.
#
# We can immediately mark the socket as a passive, listening socket via
# listen(2)

-- [photos/bridge.jpg]
Poll for the socket to be readable

# Now we can poll until an x client tries to connect to the X domain socket

-- [photos/bridge.jpg]
socketpair() for wayland protocol before fork()

# Explain that we want xwayland to be a wayland client so we want to establish
# a socket connection between the compositor and xwayland.
#
# We create a socketpair() just before fork()ing to run xwayland so
# that we can give one end of the pair to xwayland. We use an
# "WAYLAND_SOCKET" environment variable to convey the file descriptor
# to xwayland.

-- [photos/bridge.jpg]
fork() xwayland

-- [photos/bridge.jpg]
Wait for "xserver" binding

# Once we know that xwayland has bound the "xserver" interface then we
# know that the server is initialized and we can also start sending
# events.

-- [photos/bridge.jpg]
Pass listen socket to xwayland

# So that xwayland can deal with actually accept()ing the new client
# connection and also handling further client connections the file
# descriptor for the unix domain socket is passed over the wayland
# protocol to xwayland.

# The file descriptor is sent using the "listen_socket" event
# described in the xserver.xml wayland protocol.

-- [font=Monospace 20px] [photos/bridge.jpg]
wl_client_flush (xwayland_client)

# A detail to be careful about is that you flush the wayland events
# passing the listen socket to xwayland to avoid a deadlock when
# trying connecting to xwayland as an X client to become the window
# manager.

-- [photos/bridge.jpg]
Connect as window manager

# At this point the compositor now becomes a window manager for xwayland
# clients.

-- [text-align=center] [photos/bridge.jpg]
Pair surfaces & windows according
to "set_window_id" requests.

# Once xwayland is initialized we can now expect "create_surface"
# requests to the wl_compositor object that correspond to top level X
# windows.
#
# We can also expect "set_window_id" events over the wayland protocol
# to inform us about which X Window corresponds to a given xwayland
# surface.


-- [photos/bridge.jpg]
Caveats...

-- [photos/bridge.jpg] [font=40px]
Unsynchronized X and wayland protocols

# Beware of having separate X and wayland command streams. If a
# wayland surface for an x client is destroyed you might want to know
# if the window was just unmapped or really destroyed which is
# something you learn from the X protocol so now your in the awkward
# situation of having to match corresponding events in each stream.
#
# Perhaps at some point it could be better to proxy one protocol over the other
# so we know things are synchronized but for now at least we've found that
# consistently making sure to process X events before wayland events works OK
#FIXME more...

-- [photos/bridge.jpg] [font=40px]
Beware about forwarding mouse input

# This problem mostly just applies to porting X compositors to be
# hybrid compositor since they will expect to handle X motion events
# e.g. for moving windows. Compositors should only handle mouse events
# coming directly into the compositor (e.g. from evdev) because it's
# not reliable to feed events to xwayland and rely on them being
# reported back via X and being consistent with the current composited
# position of a window.

-- [photos/bridge.jpg]
Sync X windows position to screen

# Keep X window positions in synch with composited position if want
# you want X toolkit menus to behave correctly.
#
# xwayland synchronizes its xrandr state according the wayland
# compositor outputs and X toolkits use the xrandr state to ensure
# they don't position pop up menus offscreen or crossing over multiple
# screens.

-- [photos/2988748371_a16e92f0b6_b.jpg]
(N) Our own compositors...


-- [photos/cogland.png]
Cogland: A small Cogl based compositor

# Simple mini compositor directly written using the Cogl API
#
# Just supports displaying buffers. No input or window management.


-- [photos/test-wayland-surface.png]
A small Clutter based compositor

# Explain about implementing the wl_input_device interface

-- [photos/dawati-wayland.png]
Hybrid Mutter Status

-- [photos/2988748371_a16e92f0b6_b.jpg]
First a quick intro for Mutter

# Introduce what mutter is; GNOME/X compositor framework for writing
# Clutter based compositors.


# Summarize some of the mutter specifics
#   - We make MetaWindows + MetaWindowActors and MetaShapedTextures
#     just as is done for X windows

# Explain that in general the ways in which a hybrid compositor gets
# developed is going to vary a lot between code bases Some differences
# with how X and wayland clients are dealt with include
#
# - Resizing: instead of the WM overriding the size of client windows,
#   wayland clients post new buffers and the compositor just has to
#   deal with whatever size they are.
# - The compositor no longer needs to draw decorations for each client window


-- [photos/waylnad-street.jpg] [bottom]
Mutter Status

# Basically working
#
# Wayland clients are still somewhat side-band, not being involved in
# window stacking for example.

-- [photos/5338839892_7f8d2535ed_b.jpg]
Where should you start?

-- [photos/5338839892_7f8d2535ed_b.jpg] [font=40px] [text-align=center]
<span size="large"><b>Weston</b></span>

<tt>git://anongit.freedesktop.org/wayland/weston</tt>

# The demo compositor for Wayland
#
# It's heading towards being a complete usable standalone compositor.
#
# This is kept up-to-date with all the latest Wayland protocol changes
# so it's a very useful example implementation. Much of the code for
# our Mutter hybrid compositor work borrows code from Weston.
-- [photos/5338839892_7f8d2535ed_b.jpg] [font=30px]
<span size="large"><b>Our work</b></span>

Cogland
<tt>git://git.gnome.org/cogl</tt>

test-window-surface (the small Clutter compositor)
<tt>git://git.gnome.org/clutter</tt>

Our latest work is on the ‘fosdem-2012’ branches for both

Mutter
<tt>git://git.gnome.org/mutter</tt>
on the wip/wayland branch

A QT compositor
<tt>git://gitorious.org/qt-labs/qt-compositor.git</tt>
-- [photos/5338839892_7f8d2535ed_b.jpg]
\#wayland on irc.freenode.net

-- [photos/5968108862_d5240a042b_b.jpg] [bottom] [font=80px]
DEMO

--[font=18px]
Attributions

2889678711_50c3e81405_b.jpg cc by-nc-sa tinydr
494823929_a427f05ce4_b.jpg  cc by-nc-sa rcolonna
2889678725_55f1e7fbeb_b.jpg cc by-nc-sa tinydr
2889642385_0a8c8592a6_b.jpg cc by-nc-sa tinydr
5338839892_7f8d2535ed_b.jpg cc by-nc-sa waltarrrrr
5968108862_d5240a042b_b.jpg cc by 2.0 petcoffr
2889657735_5234d83de4_b.jpg cc by-nc-sa tinydr
3536874376_8faa3e977e_b.jpg cc by-nc-sa SkyprPhotography
1346915953_edab99dab8_b.jpg cc by-nc-sa 'fake is the new real'
2988748371_a16e92f0b6_b.jpg cc by-nc-nd 2.0 Christine Myaskovsky (chrissymckeen)
basketball.jpg cc by-sa 2.0 Dougtone
first-town-center.jpg cc by-sa 2.0 Dougtone
white-house.jpg cc by-sa 2.0 Dougtone
waylnad-street.jpg cc by-nc-nd 2.0 throgers
parish.jpg cc by 3.0 John Phelan
bridge.jpg public domain Daderot
town-building.jpg public domain Daderot
river.jpg public domain Daderot
depot.jpg cc by 3.0 John Phelan
middle-shool.jpg cc by 3.0 John Phelan
wayland-kerb.jpg cc by 2.0 Marcin Wichary
