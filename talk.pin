#!/usr/bin/env pinpoint
[duration=40]


-- []
(R) Writing a Wayland Compositor

# The idea of this talk is to hopefully give some insight into writing a wayland
# compositor based on some of our early experiences. So far we've written three
# compositors; each progressively more capable than the last and found it a
# good way of learning what's involved.

-- []
Robert Bragg

# - Intel Open Source Technology Center, based in London
# - Maintainer for the Cogl 3D graphics API
# - Done lots of work on Clutter
# - I've done a fair amount of work on Window managers and Graphics drivers
#   in the past.

-- []
Neil Roberts

# - Also on the visualization team in the Intel OTC.
# - Part-maintainer of Cogl
# - Recently got involved in the Wayland effort

-- [stage-color=black] [xarch.png] [bottom-right]
The current X
architecture

# The main thing to point out here is that the X architecture requires us to
# put the compositor into a separate process.
#
# Because the xserver doesn't know about the compositor scenegraph used to
# render windows its currently basically infeasible to support input
# transformations with this architecture.
#
# Because the compositor isn't directly responsible for display output it's
# also very difficult to have fine grained control over what gets displayed;
# for example compositors want to control when fullscreen applications should
# be scanned out directly by the display hardware and they also want to take
# full advantage of the displays overlay capabilities for blending sprites, ui
# and video layers together.

-- [stage-color=black] [wlarch.png] [bottom-left]
The new
architecture

# The thing to point out here is that wayland combines the compositor into the
# server process.
#
# Input redirection is now trivial because the input devices and the scenegraph
# are now owned by the same process.
#
# We can totally control the display hardware in the compositor so we can do
# whatever

--
libwayland-server

#Explain that this lib provides just the protocol marshaling stuff + some utils
#for dealing with input grabs, data device,

#Note: there's nothing specific to the rendering architecture here

--
Clients in their own world

# Explain that client surfaces all have a private coordinate space and its not
# possible to discover the surfaces of other clients like you can under X.

--
Clients are King

# Anything that's not a shared resource is handled in the client:
# - rendering,
# - client side decorations
# - keyboard maps / interpreting keyboard events

--
(R) How a compositor looks..

# We're going to run through the basic design and components of a Wayland
# compositor...

--
How a compositor looks..
• Interfaces, Events & Requests

# All interactions over the wayland protocol happen according to interfaces that
# are declared in XML


#TODO Need to demonstrate events in the xml:
-- [font=Monospace 20px]
<span color="#B22222">&lt;!--</span><span color="#B22222"> A compositor. This object is a global.  The compositor is in
     charge of combining the contents of multiple surfaces into one
     displayable output. </span><span color="#B22222">--></span>
&lt;<span color="#0000FF">interface</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">wl_compositor</span><span color="#8B2252">&quot;</span> <span color="#A0522D">version</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">1</span><span color="#8B2252">&quot;</span>>
  <span color="#B22222">&lt;</span><span color="#B22222">!--</span><span color="#B22222"> Factory request for a surface objects. A surface is akin to a
       window. </span><span color="#B22222">--></span>
  &lt;<span color="#0000FF">request</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">create_surface</span><span color="#8B2252">&quot;</span>>
    &lt;<span color="#0000FF">arg</span> <span color="#A0522D">name</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">id</span><span color="#8B2252">&quot;</span> <span color="#A0522D">type</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">new_id</span><span color="#8B2252">&quot;</span> <span color="#A0522D">interface</span>=<span color="#8B2252">&quot;</span><span color="#8B2252">wl_surface</span><span color="#8B2252">&quot;</span>/>
  &lt;/<span color="#0000FF">request</span>>
&lt;/<span color="#0000FF">interface</span>>

# Give examples of the different interfaces in a compositor
#   - wl_display - bind
#   - wl_compositor - create_surface
#   - wl_shm
#   - wl_output
#   - wl_input_device


# An interface defines a set of requests and events which can each have a name
# and a set of arguments with names and types.
#
# Requests are used for clients to ask something of the compositor.
#
# Explain that requests can't send synchronous replies, which makes sense for a
# cross process IPC protocol, but instead compositors can send events to send
# information out to clients.

#Example of sending an event from a compositor
#      wl_resource_post_event (&callback->resource,
#                              WL_CALLBACK_DONE, get_time ());


--
How a compositor looks..
• Objects

# Explain that interfaces are implemented by objects.
# Explain how compositors advertise objects implementing interfaces to clients
# - global objects that get advertised via events when a client first connects

-- [font=Monospace 20px]
Example of registering a new global object in a compositor

wl_display_add_global (compositor->wayland_display,
		       &wl_output_interface,
		       output,
		       bind_output);

--
How a compositor looks..
• Binding an interface

# Explain how clients bind to a server object interface to create a local proxy object
# Whenever a client binds an object then the compositor constructs a server side
# resource representing the clients view of that object.

#E.g.
#  if (strcmp (interface, "wl_compositor") == 0)
#    wayland_renderer->wayland_compositor =
#      wl_display_bind (display, id, &wl_compositor_interface);
#

--
(N) The rendering architecture...

--
SHM buffers

--
EGL

# EGL is a platform independent window system API
#
# It is used to create a GL or GLES context and bind into to a window
# or offscreen buffer.
#
# It can be considered a replacement for GLX.
-- [font=45px]
eglCreateDisplay(NativeDisplayType display)

# For example, to create an EGL display you have to pass it a
# NativeDisplayType. This is a platform specific pointer representing
# the display. Eg, for X it could be the X Display* pointer. It is up
# to the EGL implementation to interpret this pointer correctly.

-- [bottom] [egl-in-wayland.png]
EGL in Wayland

# Both client and compositor link to EGL.
#
# It is up to the implementation for how it passes buffers between
# client and compositor. It can define whatever internal extensions
# needed.
#
# In Mesa it will create a wl_drm global interface for the client to use.

--
EGL in Clients...

# The EGL implementation has to have specific support to interpret
# EGLNativeDisplayType and EGLNativeWindowType as wayland types.
# The client would then do the following:
--
<i>Create a wayland display object</i>

<tt>
<span color="#A020F0">struct</span> <span color="#228B22">wl_displa</span><span color="#228B22">y</span> *<span color="#A0522D">display</span> =
  wl_display_connect (<span color="#008B8B">NULL</span>);
</tt>

# This returns an object representing the connection on the socket to
# the Wayland display server. This can be considered an equivalent to
# the Display* pointer in X.
-- [font=28px]
<i>Bind to the wl_compositor interface</i>
<tt>
  <span color="#A020F0">if</span> (strcmp(interface, <span color="#8B2252">&quot;wl_compositor&quot;</span>) == 0)
    d->compositor =
      wl_display_bind(display, id,
                      &amp;wl_compositor_interface);
</tt>

# The client needs a handle to represent the compositor's global
# wl_compositor interface. It can get this by handle the 'global' event on
# the wl_display interface and then binding the object as shown.
--
wl_compositor::create_surface

# This is a method on the compositor's wl_compositor object to create
# a surface. The client generates an ID for the surface.
--[font=28px]
<i>libwayland-egl:</i>

<tt>
<span color="#A020F0">struct</span> <span color="#228B22">wl_egl_windo</span><span color="#228B22">w</span> *
<span color="#0000FF">wl_egl_window_create</span>(<span color="#A020F0">struct</span> <span color="#228B22">wl_surface</span> *<span color="#A0522D">surface</span>,
                     <span color="#228B22">int</span> <span color="#A0522D">width</span>,
                     <span color="#228B22">int</span> <span color="#A0522D">height</span>);
</tt>

# libwayland-egl is some wayland-specific functions in the EGL implementation
# This function is used to create a structure which combines a size with a
# wayland surface.
-- [font=35px]
eglCreateWindowSurface(EGLNativeWindowType)

# Once the client has a wl_egl_window* pointer it can pass that to
# EGL as the native window type to create a regular EGL surface.
#
# The surface can then be used with eglMakeCurrent to bind the GL context.
# From then on the application can just use regular GL or GLES.
--
EGL in the Compositor

# On the compositor side the compositor can use whatever EGL platform it likes.
# For example it could use an X display and an X window as a surface to create
# a compositor that is nested under X. However the EGL implementation has
# to implement this one extension...
--
EGL_WL_bind_wayland_display
# ... this extension contains one function...
-- [font=Monospace 20px]
eglBindWaylandDisplayWL()

# ... The compositor must call this to tell the EGL implementation that
# it should accept buffers passed in from clients. How this works is up
# to the implementation but in Mesa it will register a global object
# with the wl_drm interface.

--
Frame callbacks

# Explain the background to the problem
#
# Explain that the wl_surface interface has a "frame" request that creates a
# wl_callback object which emits a "done" event when the compositor next
# completes the rendering of a frame.

--
(R) Kernel Mode Setting

#Probably just do a fly by explanation....

--
libgbm

#Makes allocating drm buffers easy
#

-- [font=Monospace 20px]
gbm_create_device()

-- [font=Monospace 20px]
eglGetDisplay() with gbm device

-- [font=Monospace 20px]
struct gbm_surface

#Explain that a gbm surface is just a swap-chain of buffers but there's nothing KMS specific about a gbm surface

-- [font=Monospace 20px]
struct gbm_surface *gbm_surface_create()

#CAVEAT: This api is in flux!
#Credit Ander Conselvan de Oleveira for these patches

#Encapsulates the data structure of swap chain but doesn't actively control your display hardware

-- [font=Monospace 20px]
eglCreateWindowSurface() with gbm_surface


-- [font=Monospace 20px]
eglSwapBuffers()

-- [font=Monospace 20px]
gbm_surface_lock_front_buffer()
gbm_surface_release_buffer()

# Used to be namedgbm_surface_get/release_bo()

#TODO: explain using the KMS api

--
TTY handling

--
Block input to the tty

--
Handle signals for vt switching

--
Enter and leave graphics mode on the tty



--
(N) Cogland: A small Cogl based compositor

-- [font=Monospace 20px]
<i>Add a global object</i>

<tt>
  <span color="#A020F0">if</span> (!wl_display_add_global (compositor.wayland_display,
                              &amp;wl_compositor_interface,
                              &amp;compositor,
                              compositor_bind))
    g_error (<span color="#8B2252">&quot;Failed to register wayland compositor object&quot;</span>);

  compositor.wayland_shm = wl_shm_init (compositor.wayland_display,
                                        &amp;shm_callbacks);
</tt>
--
<i>This part is a callback</i>

<tt>
  <span color="#A020F0">if</span> (!wl_display_add_global (compositor.wayland_display,
                              &amp;wl_compositor_interface,
                              &amp;compositor,
                              <span background="#ff0000">compositor_bind</span>))
    g_error (<span color="#8B2252">&quot;Failed to register wayland compositor object&quot;</span>);

  compositor.wayland_shm = wl_shm_init (compositor.wayland_display,
                                        &amp;shm_callbacks);
</tt>

-- [font=Monospace 20px]
<i>Implementation</i>
<tt>
<span color="#A020F0">static</span> <span color="#228B22">voi</span><span color="#228B22">d</span>
<span color="#0000FF">compositor_bind</span> (<span color="#A020F0">struct</span> <span color="#228B22">wl_client</span> *<span color="#A0522D">client</span>,
                 <span color="#228B22">void</span> *<span color="#A0522D">data</span>,
                 <span color="#228B22">guint32</span> <span color="#A0522D">version</span>,
                 <span color="#228B22">guint32</span> <span color="#A0522D">id</span>)
{
  <span color="#228B22">CoglandComposito</span><span color="#228B22">r</span> *<span color="#A0522D">compositor</span> = data;

  wl_client_add_object (client, &amp;wl_compositor_interface,
                        &amp;cogland_compositor_interface, id, compositor);
}
</tt>

-- [font=Monospace 20px]
<i>Handling a buffer attach from a client</i>
<tt>
<span color="#A020F0">static</span> <span color="#228B22">voi</span><span color="#228B22">d</span>
<span color="#0000FF">cogland_surface_attach_buffer</span> (<span color="#A020F0">struct</span> <span color="#228B22">wl_client</span> *<span color="#A0522D">wayland_client</span>,
                               <span color="#A020F0">struct</span> <span color="#228B22">wl_resource</span> *<span color="#A0522D">wayland_surface_resource</span>,
                               <span color="#A020F0">struct</span> <span color="#228B22">wl_resource</span> *<span color="#A0522D">wayland_buffer_resource</span>,
                               <span color="#228B22">gint32</span> <span color="#A0522D">dx</span>, <span color="#228B22">gint32</span> <span color="#A0522D">dy</span>)
{
  <span color="#B22222">/</span><span color="#B22222">*</span><span color="#B22222">.... </span><span color="#B22222">*/</span>
  buffer->texture =
    cogl_wayland_texture_2d_new_from_buffer (compositor->cogl_context,
                                             wayland_buffer,
                                             &amp;error);
  <span color="#B22222">/</span><span color="#B22222">*</span><span color="#B22222">...</span><span color="#B22222">*/</span>
}
</tt>
--
<i>Post frame callback-done events on paint</i>
<tt>
  <span color="#A020F0">while</span> (!g_queue_is_empty (&amp;compositor->frame_callbacks))
    {
      <span color="#228B22">CoglandFrameCallbac</span><span color="#228B22">k</span> *<span color="#A0522D">callback</span> =
        g_queue_peek_head (&amp;compositor->frame_callbacks);

      wl_resource_post_event (&amp;callback->resource,
                              WL_CALLBACK_DONE, get_time ());
      wl_resource_destroy (&amp;callback->resource, 0);
    }
</tt>
--
# Examples of adding key objects: compositor, wl_shm, outputs, shell

# Examples of dealing with buffer attaches

# Example of posting the frame callback-done events


--
A small Clutter based compositor

# Explain about implementing the wl_input_device interface


--
(R) xwayland

# Introduce that X wayland is a means to support legacy X clients
#
# Introduce that the compositor is responsible for starting an X wayland server for X clients to connect too.

--
Starting X Wayland

#TODO explain the hoops involved here

--
The xwayland.xml protocol

# Explain the surface_set_xid request


--
Caveats

# Beware of having separate X and wayland command streams
# Beware how you forward mouse input
# Keep X window positions in synch with composited position if want menus to behave


--
Mutter

# Introduce what mutter is; GNOME/X compositor framework



# Explain moving shell surfaces


# Summarize some of the mutter specifics
#   - We make MetaWindows + MetaWindowActors and MetaShapedTextures just as is done for X windows

# Explain that in general the ways in which a hybrid compositor gets developed is going to vary a lot between code bases
# Some differences with how X and wayland clients are dealt with include
# - Resizing: instead of the WM overriding the size of client windows, wayland clients post new buffers and the compositor just has to deal with whatever size they are.
# - The compositor no longer needs to draw decorations for each client window


-- [photos/waylnad-street.jpg] [bottom]
Mutter Status

# Basically working
# Wayland clients are still somewhat side-band, not being involved in window stacking for example.

--
(N) Where should you start?

# Well there's quite a bit of code to reference now:
#   There's obviously the Weston compositor which you should definitely take a look at.
#   There's the tiny Cogland example compositor we have
#   There's the small test-wayland-surface compositor we have as an interactive test for Clutter
#   There's now the Mutter hybrid compositor to take a look at too.
#   There is QT-Compositor on gitorious
#
# recommend others interested in writing a wayland compositor that you start
# with a few toys

--
DEMO

--
Attributions

2889678711_50c3e81405_b.jpg cc by-nc-sa tinydr
494823929_a427f05ce4_b.jpg  cc by-nc-sa rcolonna
2889678725_55f1e7fbeb_b.jpg cc by-nc-sa tinydr
2889642385_0a8c8592a6_b.jpg cc by-nc-sa tinydr
5338839892_7f8d2535ed_b.jpg cc by-nc-sa waltarrrrr
5968108862_d5240a042b_b.jpg cc by 2.0 petcoffr
2889657735_5234d83de4_b.jpg cc by-nc-sa tinydr
3536874376_8faa3e977e_b.jpg cc by-nc-sa SkyprPhotography
1346915953_edab99dab8_b.jpg cc by-nc-sa 'fake is the new real'
2988748371_a16e92f0b6_b.jpg cc by-nc-nd 2.0 Christine Myaskovsky (chrissymckeen)
